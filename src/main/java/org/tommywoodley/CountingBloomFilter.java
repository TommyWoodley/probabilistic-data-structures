package org.tommywoodley;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

public class CountingBloomFilter<E> implements ProbabilisticSet<E> {

  private final int k;
  private final int setSize;
  private int numberOfAddedElements;
  private final int[] countingFilter;
  static final Charset charset = StandardCharsets.UTF_8; // encoding used for storing hash values as strings

  private CountingBloomFilter(double c, int n, int k) {
    this.k = k;
    this.setSize = (int)Math.ceil(c * n);
    this.numberOfAddedElements = 0;
    this.countingFilter = new int[setSize];
  }

  /**
   * Inserts an element into the Counting Bloom filter.
   * <p>
   * The put method adds the specified element to the Bloom filter, by imcrementing the
   * counter for the corresponding hashes from that element.
   *
   * @param element The element to be added to the Bloom filter.
   * @throws NullPointerException If the specified element is null.
   */
  @Override
  public void put(E element) {
    put(element.toString().getBytes(charset));
  }

  private void put(byte[] bytes) {
    int[] hashes = Hasher.createHashes(bytes, k);

    for (int hash : hashes) {
      countingFilter[Math.abs(hash % setSize)]++;
    }
    numberOfAddedElements++;
  }

  /**
   * Checks if the Bloom filter might contain the specified element.
   * <p>
   * This method does not provide a definitive answer and may return false positives
   * due to potential hash collisions. If this method returns true for a given element, it
   * means that the underlying counter for all hashes is greater than 1. However, false
   * positives are possible, and it does not guarantee that the element is definitely in
   * the set. If this method returns false it can be guaranteed that the element is not in the set.
   *
   * @param element The element to be checked for presence in the bloom filter.
   * @return {@code true} if the element might be in the set, {@code false} if it is definitely not in the set.
   * @throws NullPointerException If the specified element is null.
   */
  @Override
  public boolean mightContain(E element) {
    return mightContain(element.toString().getBytes(charset));
  }

  private boolean mightContain(byte[] bytes) {
    int[] hashes = Hasher.createHashes(bytes, k);

    for (int hash : hashes) {
      if (countingFilter[Math.abs(hash % setSize)] == 0) {
        return false;
      }
    }
    return true;
  }

  /**
   * Returns the number of elements in the Bloom filter.
   * <p>
   * Note that this exactly corresponds to the number of elements inserted and will
   * count duplicates.
   *
   * @return The number of elements in the bloom filter.
   */
  @Override
  public int size() {
    return this.numberOfAddedElements;
  }

  /**
   * Removes an element from the Counting Bloom Filter.
   * <p>
   * Decreases the counters for the hash positions generated by the element's hash codes.
   * If the element was not previously inserted, no action is taken.
   *
   * @param element the element to be removed from the Counting Bloom Filter
   * @throws NullPointerException if the specified element is null
   */
  public void remove(E element) {
    remove(element.toString().getBytes(charset));
  }

  private void remove(byte[] bytes) {
    if (!mightContain(bytes)) {
      return;
    }

    int[] hashes = Hasher.createHashes(bytes, k);
    for (int hash : hashes) {
      countingFilter[Math.abs(hash % setSize)]++;
    }
    numberOfAddedElements++;
  }
}
